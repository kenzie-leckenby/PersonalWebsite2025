<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Japanese Mahjong â€” Kanji Challenge Fixed</title>
<style>
  /* TILE SIZE: 80px WIDE x 60px HIGH */
  :root{--tile-width:120px; --tile-height:80px; --tile-gap:8px} 
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans JP',sans-serif; background:linear-gradient(180deg,#eef 0%,#fff 60%); margin:0; padding:18px; color:#123}
  .app{max-width:1300px;margin:0 auto;display:grid;grid-template-columns:360px 1fr;gap:20px}
  header{grid-column:1/-1;display:flex;align-items:center;gap:16px;flex-wrap:wrap}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  
  /* Dropdown styling */
  select { padding: 8px 10px; border-radius: 8px; border: 1px solid #cbd5e0; background: #fff; cursor: pointer; color:#2d3748; font-weight:600; outline:none; box-shadow:0 2px 4px rgba(0,0,0,0.05); }
  select:hover { border-color:#a0aec0; }
  
  /* Container for mode and lesson selectors */
  .mode-selectors { display: flex; gap: 8px; align-items: center; }

  button{background:#2b6cb0;border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer}
  button:hover{background:#2c5282}
  button.ghost{background:transparent;color:#2b6cb0;border:1px solid rgba(43,108,176,.15)}
  button.ghost:hover{background:rgba(43,108,176,.05)}
  button:disabled{opacity:0.6; cursor: not-allowed; background:#9c9c9c}
  
  .panel{background:rgba(255,255,255,.9);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.08)}
  .left{display:flex;flex-direction:column;gap:12px}
  .stats{display:flex;flex-direction:column;gap:6px}
  .stat{font-size:14px}
  /* Adjusted height to fit the smaller tile layout */
  .board-wrap{position:relative;height:480px;background:linear-gradient(180deg,#e7f3ff, #f3fbff); border-radius:12px;overflow:hidden;padding:18px}
  .board{position:relative;width:100%;height:100%;transform:translateZ(0)}
  .tile{
      position:absolute;
      width:var(--tile-width); 
      height:var(--tile-height); 
      border-radius:8px;
      box-shadow:0 6px 12px rgba(0,0,0,.15);
      display:flex;align-items:center;justify-content:center;
      font-size:24px; /* Reduced font size */
      font-weight:600;
      user-select:none;
      background:#fff;
      border:3px solid #f0f6fb;
      transition:transform .2s ease,box-shadow .2s ease, opacity .2s ease, font-size .2s ease;
  }
  .tile.layer-0{border-color:#2b6cb0}
  .tile.layer-1{border-color:#2c7a7b}
  .tile.layer-2{border-color:#d69e2e}
  .tile.layer-3{border-color:#9c27b0}
  .tile.kanji-char{font-size: 30px;} /* Reduced kanji font size */
  .tile .corner{position:absolute;font-size:10px;color:#555}
  .tile.kanji-char .corner{font-size: 8px;} 
  .tile .corner.tl{top:2px;left:2px}
  .tile .corner.tr{top:2px;right:2px}
  .tile .corner.bl{bottom:2px;left:2px}
  .tile .corner.br{bottom:2px;right:2px}
  .tile.locked{opacity:.18;filter:grayscale(.2)}
  .tile.free{box-shadow:0 10px 22px rgba(0,0,0,.18)}
  
  /* é¸æŠæ™‚ã®ãƒœãƒ¼ãƒ€ãƒ¼è‰² */
  .tile.selected{
      outline:3px solid #ff0000; 
      transform:translateY(-6px) scale(1.02)
  }
  
  /* HINT/SELECTED GLOW EFFECT (Yellow) - STRONGER */
  .tile.glow{box-shadow:0 0 24px 10px rgba(255,255,0,1) !important; z-index:999}
  /* MATCH SUCCESS GLOW EFFECT (Vibrant Pink) - STRONGER and Scale */
  .tile.glow2{box-shadow:0 0 24px 10px rgba(255,0,200,1) !important; z-index:999; transform:scale(1.15);} 

  .tile.removed{display:none}
  .legend{font-size:13px;color:#334}
  .footer{grid-column:1/-1;text-align:center;margin-top:20px;color:#446}
  .controls small{display:block;font-size:12px;color:#345}
  .hint {background:#fff3cd;color:#6b4a00;border:1px solid #ffeeba;padding:6px;border-radius:6px}
  .topbar-right{margin-left:auto;display:flex;gap:8px;align-items:center}
  .toast{position:fixed;left:50%;top:40%;transform:translate(-50%,-50%);background:#1f2937;color:white;padding:14px 18px;border-radius:10px;font-size:18px;opacity:0;transition:opacity .3s ease;cursor:pointer; z-index:1000}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Japanese Mahjong</h1>
    
    <div class="mode-selectors">
        <select id="modeSelect">
            <option value="hiragana">Hiragana Only (ã‚=ã‚)</option>
            <option value="katakana">Katakana Only (ã‚¢=ã‚¢)</option>
            <option value="mixed">Mix-Try (ã‚=ã‚ OR ã‚¢=ã‚¢)</option>
            <option value="hard">ğŸ”¥ Hard Mode (ã‚=ã‚¢)</option>
            <option value="kanji">æ¼¢å­— Kanji Match</option>
        </select>

        <select id="kanjiLessonSelect" style="display: none;">
            </select>
    </div>

    <div class="controls topbar-right">
      <button id="restart">Restart</button>
      <button id="shuffle">Shuffle</button>
      <button id="hintBtn" class="ghost">Hint</button>
      <button id="undoBtn" class="ghost">Undo</button>
      <div class="panel" style="padding:6px 10px;display:flex;gap:12px;align-items:center">
        <div class="stat">Score: <strong id="score">0</strong></div>
      </div>
    </div>
  </header>

  <aside class="left">
    <div class="panel">
      <h3 style="margin:0 0 8px 0">How to play</h3>
      <p class="legend">Match two tiles to remove them. Tiles must be free (no tile on top, one side open).</p>
    </div>

    <div class="panel stats">
      <div class="stat">Selected: <span id="selectedCount">0</span></div>
      <div class="stat">Pairs left: <span id="pairsLeft">0</span></div>
      <div class="stat">Tiles remaining: <span id="tilesLeft">0</span></div>
    </div>

    <div class="panel">
      <h4 style="margin:0 0 8px 0">Active Set & Rules</h4>
      <p id="descText" style="margin:0;font-size:14px">Hiragana mode active. Match identical characters.</p>
    </div>
  </aside>

  <main>
    <div class="board-wrap panel">
      <div id="board" class="board"></div>
    </div>
  </main>

  <div class="footer" style="text-align:center; margin-top:20px; font-size:14px; opacity:0.7;">Designed and Created by Ken, Co-coded by ChatGPT and Gemini</div>
</div>

<div id="toast" class="toast" style="display:none"></div>

<script>
(function(){
  // Constants for 80px wide x 60px high tiles
  const TILE_WIDTH=80; 
  const TILE_HEIGHT=60;
  
  const HIRAGANA=['ã‚','ã„','ã†','ãˆ','ãŠ','ã‹','ã','ã','ã‘','ã“','ã•','ã—','ã™','ã›','ã','ãŸ','ã¡','ã¤','ã¦','ã¨','ãª','ã«','ã¬','ã­','ã®','ã¯','ã²','ãµ','ã¸','ã»','ã¾','ã¿','ã‚€','ã‚','ã‚‚','ã‚„','ã‚†','ã‚ˆ','ã‚‰','ã‚Š','ã‚‹','ã‚Œ','ã‚','ã‚','ã‚’','ã‚“'];
  const KATAKANA=['ã‚¢','ã‚¤','ã‚¦','ã‚¨','ã‚ª','ã‚«','ã‚­','ã‚¯','ã‚±','ã‚³','ã‚µ','ã‚·','ã‚¹','ã‚»','ã‚½','ã‚¿','ãƒ','ãƒ„','ãƒ†','ãƒˆ','ãƒŠ','ãƒ‹','ãƒŒ','ãƒ','ãƒ','ãƒ','ãƒ’','ãƒ•','ãƒ˜','ãƒ›','ãƒ','ãƒŸ','ãƒ ','ãƒ¡','ãƒ¢','ãƒ¤','ãƒ¦','ãƒ¨','ãƒ©','ãƒª','ãƒ«','ãƒ¬','ãƒ­','ãƒ¯','ãƒ²','ãƒ³'];
  
  // --- KANJI LESSON DATA STRUCTURE ---
  const KANJI_LESSONS = {
    'L1': {
      name: 'Lesson 1: Random Number (1-99) (Digits <=> Hiragana)',
      pairs: [] 
    },
    'L2': {
      name: 'Lesson 2: Random Number (1-99) (Digits <=> Katakana)',
      pairs: [] 
    },
    
    'L3': {
      name: 'Lesson 3: Daily/Numbers/Time (15 Pairs)',
      pairs: [
        { kanji: 'ä¸€', reading: 'ã„ã¡' }, { kanji: 'äºŒ', reading: 'ã«' }, { kanji: 'ä¸‰', reading: 'ã•ã‚“' },
        { kanji: 'å››', reading: 'ã‚ˆã‚“' }, { kanji: 'äº”', reading: 'ã”' }, { kanji: 'å…­', reading: 'ã‚ã' },
        { kanji: 'ä¸ƒ', reading: 'ãªãª' }, { kanji: 'å…«', reading: 'ã¯ã¡' }, { kanji: 'ä¹', reading: 'ãã‚…ã†' },
        { kanji: 'å', reading: 'ã˜ã‚…ã†' }, { kanji: 'ç™¾', reading: 'ã²ã‚ƒã' }, { kanji: 'åƒ', reading: 'ã›ã‚“' },
        { kanji: 'ä¸‡', reading: 'ã¾ã‚“' }, { kanji: 'å††', reading: 'ãˆã‚“' }, { kanji: 'æ™‚', reading: 'ã˜' }
      ]
    }, 
    'L4': {
      name: 'Lesson 4: Mary\'s Weekend/Days/Locations(14 Pairs)',
      pairs: [
        { kanji: 'æ—¥', reading: 'ã«ã¡' }, { kanji: 'æœ¬', reading: 'ã»ã‚“' }, { kanji: 'äºº', reading: 'ã˜ã‚“' },
        { kanji: 'æœˆ', reading: 'ã’ã¤' }, { kanji: 'ç«', reading: 'ã‹' }, { kanji: 'æ°´', reading: 'ã¿ãš' },
        { kanji: 'æœ¨', reading: 'ã‚‚ã' }, { kanji: 'é‡‘', reading: 'ãã‚“' }, { kanji: 'åœŸ', reading: 'ã¨' },
        { kanji: 'æ›œ', reading: 'ã‚ˆã†' }, { kanji: 'ä¸Š', reading: 'ã†ãˆ' }, { kanji: 'ä¸‹', reading: 'ã—ãŸ' },
        { kanji: 'ä¸­', reading: 'ãªã‹' }, { kanji: 'åŠ', reading: 'ã¯ã‚“' } 
      ]
    }, 
    'L5': {
      name: 'Lesson 5: Travel/Nature/Action(14 Pairs)',
      pairs: [
        { kanji: 'å±±', reading: 'ã‚„ã¾' }, { kanji: 'å·', reading: 'ã‹ã‚' }, { kanji: 'å…ƒ', reading: 'ã’ã‚“' },
        { kanji: 'æ°—', reading: 'ã' }, { kanji: 'å¤©', reading: 'ã¦ã‚“' }, { kanji: 'ç§', reading: 'ã‚ãŸã—' },
        { kanji: 'ä»Š', reading: 'ã„ã¾' }, { kanji: 'ç”°', reading: 'ãŸ' }, { kanji: 'å¥³', reading: 'ãŠã‚“ãª' },
        { kanji: 'ç”·', reading: 'ãŠã¨ã“' }, { kanji: 'è¦‹', reading: 'ã¿' }, { kanji: 'è¡Œ', reading: 'ã„' },
        { kanji: 'é£Ÿ', reading: 'ãŸ' }, { kanji: 'é£²', reading: 'ã„ã‚“' } 
      ]
    }, 
    'L6': {
      name: 'Lesson 6: My Favorite Restaurant/Directions/School(15 Pairs)',
      pairs: [
        { kanji: 'æ±', reading: 'ã²ãŒã—' }, { kanji: 'è¥¿', reading: 'ã«ã—' }, { kanji: 'å—', reading: 'ã¿ãªã¿' },
        { kanji: 'åŒ—', reading: 'ããŸ' }, { kanji: 'å£', reading: 'ãã¡' }, { kanji: 'å‡º', reading: 'ã§' },
        { kanji: 'å³', reading: 'ã¿ã' }, { kanji: 'å·¦', reading: 'ã²ã ã‚Š' }, { kanji: 'åˆ†', reading: 'ãµã‚“' },
        { kanji: 'å¤§', reading: 'ã ã„' }, 
        { kanji: 'å­¦', reading: 'ãŒã' }, { kanji: 'å¤–', reading: 'ãŒã„' },
        { kanji: 'å…ˆ', reading: 'ã›ã‚“' }, { kanji: 'ç”Ÿ', reading: 'ã›ã„' } , { kanji: 'å›½', reading: 'ã“ã' }
      ]
    }, 
    'L7': {
      name: 'Lesson 7: Maryâ€™s Letter',
      pairs: [
        { kanji: 'äº¬', reading: 'ãã‚‡ã†' }, { kanji: 'å­', reading: 'ã“' }, { kanji: 'å°', reading: 'ã—ã‚‡ã†' },
        { kanji: 'ä¼š', reading: 'ã‹ã„' }, { kanji: 'ç¤¾', reading: 'ã—ã‚ƒ' }, { kanji: 'çˆ¶', reading: 'ã¡ã¡' },
        { kanji: 'æ¯', reading: 'ã¯ã¯' }, { kanji: 'é«˜', reading: 'ã“ã†' }, { kanji: 'æ ¡', reading: 'ã“ã†' },
        { kanji: 'æ¯', reading: 'ã¾ã„' }, { kanji: 'èª', reading: 'ã”' }, { kanji: 'æ–‡', reading: 'ã¶ã‚“' },
        { kanji: 'å¸°', reading: 'ã‹ãˆ' }, { kanji: 'å…¥', reading: 'ã«ã‚…ã†' }
      ]
    }, 
    'L8': {
      name: 'Lesson 8: Japanese Office Workers',
      pairs: [
        { kanji: 'å“¡', reading: 'ã„ã‚“' }, { kanji: 'æ–°', reading: 'ã—ã‚“' }, { kanji: 'è', reading: 'ã¶ã‚“' },
        { kanji: 'ä½œ', reading: 'ã•ã' }, { kanji: 'ä»•', reading: 'ã—' }, { kanji: 'äº‹', reading: 'ã“ã¨' },
        { kanji: 'é›»', reading: 'ã§ã‚“' }, { kanji: 'è»Š', reading: 'ã—ã‚ƒ' }, { kanji: 'ä¼‘', reading: 'ãã‚…ã†' },
        { kanji: 'è¨€', reading: 'ã’ã‚“' }, { kanji: 'èª­', reading: 'ã©ã' }, { kanji: 'æ€', reading: 'ãŠã‚‚' },
        { kanji: 'æ¬¡', reading: 'ã¤ã' }, { kanji: 'ä½•', reading: 'ãªã«' }
      ]
    }, 
    'L9': {
      name: 'Lesson 9: Soraâ€™s Diary',
      pairs: [
        { kanji: 'åˆ', reading: 'ã”' }, { kanji: 'å‰', reading: 'ã¾ãˆ' }, { kanji: 'å', reading: 'ãª' },
        { kanji: 'ç™½', reading: 'ã—ã‚' }, { kanji: 'é›¨', reading: 'ã‚ã‚' }, { kanji: 'æ›¸', reading: 'ã‹' },
        { kanji: 'å‹', reading: 'ã¨ã‚‚' }, { kanji: 'é–“', reading: 'ã‚ã„ã ' }, { kanji: 'å®¶', reading: 'ã„ãˆ' },
        { kanji: 'è©±', reading: 'ã¯ãª' }, { kanji: 'å°‘', reading: 'ã—ã‚‡ã†' }, { kanji: 'å¤', reading: 'ãµã‚‹' },
        { kanji: 'çŸ¥', reading: 'ã—' }, { kanji: 'æ¥', reading: 'ã‚‰ã„' }, { kanji: 'å¾Œ', reading: 'ã”' }
      ]
    }, 
    'L10': {
      name: 'Lesson 10: The Folktale Kasajizo',
      pairs: [
        { kanji: 'ä½', reading: 'ã™' }, { kanji: 'æ­£', reading: 'ã›ã„' }, { kanji: 'å¹´', reading: 'ã¨ã—' },
        { kanji: 'å£²', reading: 'ã†' }, { kanji: 'è²·', reading: 'ã‹' }, { kanji: 'ç”º', reading: 'ã¾ã¡' },
        { kanji: 'é•·', reading: 'ã¡ã‚‡ã†' }, { kanji: 'é“', reading: 'ã¿ã¡' }, { kanji: 'é›ª', reading: 'ã‚†ã' },
        { kanji: 'ç«‹', reading: 'ãŸ' }, { kanji: 'è‡ª', reading: 'ã˜' }, { kanji: 'å¤œ', reading: 'ã‚ˆã‚‹' },
        { kanji: 'æœ', reading: 'ã‚ã•' }, { kanji: 'æŒ', reading: 'ã‚‚' }
      ]
    }, 
    'L11': {
      name: 'Lesson 11: Looking for Friends/Members',
      pairs: [
        { kanji: 'æ‰‹', reading: 'ã¦' }, { kanji: 'ç´™', reading: 'ã‹ã¿' }, { kanji: 'å¥½', reading: 'ã™' },
        { kanji: 'è¿‘', reading: 'ã¡ã‹' }, { kanji: 'æ˜', reading: 'ã‚ã‹' }, { kanji: 'ç—…', reading: 'ã³ã‚‡ã†' },
        { kanji: 'é™¢', reading: 'ã„ã‚“' }, { kanji: 'æ˜ ', reading: 'ãˆã„' }, { kanji: 'ç”»', reading: 'ãŒ' },
        { kanji: 'æ­Œ', reading: 'ã†ãŸ' }, { kanji: 'å¸‚', reading: 'ã—' }, { kanji: 'æ‰€', reading: 'ã¨ã“ã‚' },
        { kanji: 'å‹‰', reading: 'ã¹ã‚“' }, { kanji: 'å¼·', reading: 'ãã‚‡ã†' }, { kanji: 'æœ‰', reading: 'ã‚' },
        { kanji: 'æ—…', reading: 'ãŸã³' }
      ]
    }, 
    'L12': {
      name: 'Lesson 12: Tanabata Festival',
      pairs: [
        { kanji: 'æ˜”', reading: 'ã‚€ã‹ã—' }, { kanji: 'ã€…', reading: 'ã®ã¾' }, { kanji: 'ç¥', reading: 'ã‹ã¿' },
        { kanji: 'æ—©', reading: 'ã¯ã‚„' }, { kanji: 'èµ·', reading: 'ãŠã' }, { kanji: 'ç‰›', reading: 'ã†ã—' },
        { kanji: 'ä½¿', reading: 'ã¤ã‹' }, { kanji: 'åƒ', reading: 'ã¯ãŸã‚‰' }, { kanji: 'é€£', reading: 'ã‚Œã‚“' },
        { kanji: 'åˆ¥', reading: 'ã¹ã¤' }, { kanji: 'åº¦', reading: 'ã©' }, { kanji: 'èµ¤', reading: 'ã‚ã‹' },
        { kanji: 'é’', reading: 'ã‚ãŠ' }, { kanji: 'è‰²', reading: 'ã„ã‚' }
      ]
    },
  };
  // ------------------------------------

  // --- Utility function for number reading (UNCHANGED) ---
  function numberToJapaneseReading(num, kanaType = 'hiragana') {
    if (num < 1 || num > 99) return num.toString();
    
    const h = kanaType === 'hiragana';
    
    const units = h ? ['ãœã‚', 'ã„ã¡', 'ã«', 'ã•ã‚“', 'ã‚ˆã‚“', 'ã”', 'ã‚ã', 'ãªãª', 'ã¯ã¡', 'ãã‚…ã†'] : ['ã‚¼ãƒ­', 'ã‚¤ãƒ', 'ãƒ‹', 'ã‚µãƒ³', 'ãƒ¨ãƒ³', 'ã‚´', 'ãƒ­ã‚¯', 'ãƒŠãƒŠ', 'ãƒãƒ', 'ã‚­ãƒ¥ã‚¦'];
    const tens = h ? ['', 'ã˜ã‚…ã†', 'ã«ã˜ã‚…ã†', 'ã•ã‚“ã˜ã‚…ã†', 'ã‚ˆã‚“ã˜ã‚…ã†', 'ã”ã˜ã‚…ã†', 'ã‚ãã˜ã‚…ã†', 'ãªãªã˜ã‚…ã†', 'ã¯ã¡ã˜ã‚…ã†', 'ãã‚…ã†ã˜ã‚…ã†'] : ['', 'ã‚¸ãƒ¥ã‚¦', 'ãƒ‹ã‚¸ãƒ¥ã‚¦', 'ã‚µãƒ³ã‚¸ãƒ¥ã‚¦', 'ãƒ¨ãƒ³ã‚¸ãƒ¥ã‚¦', 'ã‚´ã‚¸ãƒ¥ã‚¦', 'ãƒ­ã‚¯ã‚¸ãƒ¥ã‚¦', 'ãƒŠãƒŠã‚¸ãƒ¥ã‚¦', 'ãƒãƒã‚¸ãƒ¥ã‚¦', 'ã‚­ãƒ¥ã‚¦ã‚¸ãƒ¥ã‚¦'];

    let reading = '';
    const n = num;

    if (n >= 10) {
        const tenDigit = Math.floor(n / 10);
        const remaining = n % 10;
        
        if (tenDigit === 1) {
            reading += (h ? 'ã˜ã‚…ã†' : 'ã‚¸ãƒ¥ã‚¦');
        } else {
            reading += tens[tenDigit];
        }
        num = remaining;
    }

    if (num > 0) {
        if (reading.endsWith(h ? 'ã˜ã‚…ã†' : 'ã‚¸ãƒ¥ã‚¦')) {
             reading += units[num];
        } else {
            reading += units[num];
        }
    } else if (n === 0) {
        return units[0];
    }
    
    return reading.trim();
  }
  // ------------------------------------


  // Mapping for Hard Mode
  const CHAR_MAP = {};
  HIRAGANA.forEach((h, i) => {
      CHAR_MAP[h] = KATAKANA[i];
      CHAR_MAP[KATAKANA[i]] = h;
  });

  // Mode state variables
  let currentSet = HIRAGANA;
  let currentMode = 'hiragana';
  let currentKanjiLessonId = 'L1'; 
  let gameFinished = false;

  // --- LAYOUT DEFINITIONS (UNCHANGED) ---
  const LAYOUT_POINTS_BUILDER = (points, yOff, xStart, xEnd, layer) => {
    for(let x=xStart; x<=xEnd; x+=2) points.push({x:x, y:yOff, layer:layer});
  };
  
  // 1. STANDARD LAYOUT (34 tiles / 17 pairs)
  const STANDARD_LAYOUT_POINTS = [];
  LAYOUT_POINTS_BUILDER(STANDARD_LAYOUT_POINTS, 0, 1, 13, 0); 
  LAYOUT_POINTS_BUILDER(STANDARD_LAYOUT_POINTS, 2, 1, 13, 0); 
  LAYOUT_POINTS_BUILDER(STANDARD_LAYOUT_POINTS, 4, 1, 13, 0); 
  LAYOUT_POINTS_BUILDER(STANDARD_LAYOUT_POINTS, 1, 3, 11, 1); 
  LAYOUT_POINTS_BUILDER(STANDARD_LAYOUT_POINTS, 3, 3, 11, 1); 
  LAYOUT_POINTS_BUILDER(STANDARD_LAYOUT_POINTS, 2, 5, 9, 2);  
  
  // 2. FIXED KANJI CHALLENGE LAYOUT (30 tiles / 15 pairs) 
  const KANJI_LAYOUT_POINTS = [];
  KANJI_LAYOUT_POINTS.push({x:7, y:2, layer:3}); 
  KANJI_LAYOUT_POINTS.push({x:5, y:2, layer:3}); 
  LAYOUT_POINTS_BUILDER(KANJI_LAYOUT_POINTS, 2, 5, 9, 2); 
  LAYOUT_POINTS_BUILDER(KANJI_LAYOUT_POINTS, 0, 5, 9, 2); 
  KANJI_LAYOUT_POINTS.push({x:7, y:4, layer:2}); 
  KANJI_LAYOUT_POINTS.push({x:3, y:2, layer:2});
  LAYOUT_POINTS_BUILDER(KANJI_LAYOUT_POINTS, 2, 3, 11, 1); 
  LAYOUT_POINTS_BUILDER(KANJI_LAYOUT_POINTS, 4, 5, 9, 1); 
  KANJI_LAYOUT_POINTS.push({x:11, y:0, layer:1});
  KANJI_LAYOUT_POINTS.push({x:3, y:0, layer:1});
  LAYOUT_POINTS_BUILDER(KANJI_LAYOUT_POINTS, 4, 1, 13, 0); 
  LAYOUT_POINTS_BUILDER(KANJI_LAYOUT_POINTS, 0, 1, 5, 0);
  
  function shuffleArray(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a}

  let tiles=[];
  
  function getRandomNumber(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  
  function buildTiles(){
    tiles = [];
    
    let layoutPoints;
    let activeLessonPairs = [];
    
    if (currentMode === 'kanji') {
        layoutPoints = KANJI_LAYOUT_POINTS; 
        
        if (!KANJI_LESSONS[currentKanjiLessonId]) {
            currentKanjiLessonId = 'L3'; 
        }
        
        if (currentKanjiLessonId === 'L1' || currentKanjiLessonId === 'L2') {
             // Dynamic Number Lesson Generation (1-99)
             const kanaType = currentKanjiLessonId === 'L1' ? 'hiragana' : 'katakana';
             let neededPairs = layoutPoints.length / 2;
             
             let uniqueNumbers = new Set();
             while (uniqueNumbers.size < neededPairs) {
                 let num = getRandomNumber(1, 99);
                 uniqueNumbers.add(num);
             }
             
             activeLessonPairs = Array.from(uniqueNumbers).map(num => ({
                 kanji: num.toString(), 
                 reading: numberToJapaneseReading(num, kanaType) 
             }));
             
        } else {
            // Static Kanji Lesson Generation (L3+)
            activeLessonPairs = KANJI_LESSONS[currentKanjiLessonId].pairs;
        }
        
    } else {
        layoutPoints = STANDARD_LAYOUT_POINTS; 
    }
    
    let neededPairs = layoutPoints.length / 2;
    let chars = [];
    
    if (currentMode === 'kanji') {
        const pairsInLesson = activeLessonPairs.length;
        neededPairs = Math.min(neededPairs, pairsInLesson);
        
        if (neededPairs * 2 < layoutPoints.length) {
            let cullingPoints = [...layoutPoints];
            cullingPoints.sort((a, b) => b.layer - a.layer || a.y - b.y || a.x - b.x);
            layoutPoints = cullingPoints.slice(layoutPoints.length - neededPairs * 2);
        }
        
        const pairsToUse = shuffleArray(activeLessonPairs).slice(0, neededPairs);
        chars = pairsToUse.flatMap(p => [p.kanji, p.reading]);
        
    } else if (currentMode === 'hard') {
        let baseChars = shuffleArray(HIRAGANA).slice(0, neededPairs);
        chars = baseChars.flatMap(h => [h, CHAR_MAP[h]]);
        
    } else {
        let pool = [];
        while (pool.length < neededPairs) pool = pool.concat(currentSet);
        pool = shuffleArray(pool).slice(0, neededPairs);
        chars = pool.concat(pool); 
    }
    
    // Final shuffle of the characters array before assigning to positions
    chars = shuffleArray(chars);
    
    let ci = 0;
    layoutPoints.forEach((p, i) => {
      tiles.push({id:i, char: chars[ci++], x: p.x, y: p.y, layer: p.layer, removed: false});
    });
    
    tiles.forEach((t, i) => t.id = i);
  }
  
  function shuffleBoard() {
      const aliveTiles = tiles.filter(t => !t.removed);
      if (aliveTiles.length === 0) return;

      let newChars = [];
      let neededPairs = Math.floor(aliveTiles.length / 2); 
      
      if (currentMode === 'kanji') {
          if (currentKanjiLessonId === 'L1' || currentKanjiLessonId === 'L2') {
               // Dynamic Number Lesson Re-Generation (Shuffle 1-99)
               const kanaType = currentKanjiLessonId === 'L1' ? 'hiragana' : 'katakana';
               let uniqueNumbers = new Set();
               while (uniqueNumbers.size < neededPairs) {
                   let num = getRandomNumber(1, 99);
                   uniqueNumbers.add(num);
               }
               
               const newPairs = Array.from(uniqueNumbers).map(num => ({
                   kanji: num.toString(), 
                   reading: numberToJapaneseReading(num, kanaType) 
               }));
               
               newChars = newPairs.flatMap(p => [p.kanji, p.reading]);
               
          } else {
              // Static Kanji Lesson Re-Generation (Shuffle)
              const activeLessonPairs = KANJI_LESSONS[currentKanjiLessonId].pairs;
              const pairsToUse = shuffleArray(activeLessonPairs).slice(0, neededPairs);
              newChars = pairsToUse.flatMap(p => [p.kanji, p.reading]);
          }
          
      } else if (currentMode === 'hard') {
          let remainingHiragana = Array.from(new Set(aliveTiles.map(t => t.char).filter(c => HIRAGANA.includes(c))));
          
          let baseChars = shuffleArray(remainingHiragana).slice(0, neededPairs);
          newChars = baseChars.flatMap(h => [h, CHAR_MAP[h]]);

      } else { 
          let chars = aliveTiles.map(t => t.char);
          let charCounts = {};
          chars.forEach(c => charCounts[c] = (charCounts[c] || 0) + 1);

          let rePaireableChars = Object.keys(charCounts).filter(c => charCounts[c] >= 2);
          
          rePaireableChars = shuffleArray(rePaireableChars).slice(0, neededPairs);
          
          newChars = rePaireableChars.flatMap(c => [c, c]);
      }
      
      if (newChars.length !== aliveTiles.length) {
          newChars = shuffleArray(aliveTiles.map(t => t.char));
      }
      
      newChars = shuffleArray(newChars);
      
      aliveTiles.forEach((t, i) => {
          t.char = newChars[i];
      });
      
      renderBoard();
  }
  
  
  // --- MATCHING LOGIC (UNCHANGED) ---
  function isMatch(charA, charB) {
      if (currentMode === 'kanji') {
          if (currentKanjiLessonId === 'L1' || currentKanjiLessonId === 'L2') {
             const kanaType = currentKanjiLessonId === 'L1' ? 'hiragana' : 'katakana';
             
             let digitStr, readingStr;
             
             if (!isNaN(parseInt(charA)) && isFinite(charA) && charA.length > 0) {
                 digitStr = charA;
                 readingStr = charB;
             } 
             else if (!isNaN(parseInt(charB)) && isFinite(charB) && charB.length > 0) {
                 digitStr = charB;
                 readingStr = charA;
             } else {
                 return false; 
             }
             
             const correctReading = numberToJapaneseReading(parseInt(digitStr), kanaType);
             
             return readingStr === correctReading;
             
          } else {
              // Static Kanji matching (L3+)
              const activeLessonPairs = KANJI_LESSONS[currentKanjiLessonId].pairs;
              
              return activeLessonPairs.some(p => 
                 (p.kanji === charA && p.reading === charB) || 
                 (p.kanji === charB && p.reading === charA)
              );
          }
          
      } else if (currentMode === 'hard') {
          return CHAR_MAP[charA] === charB;
      } else {
          return charA === charB;
      }
  }
  
  
  // --- DOM Element References ---
  const board=document.getElementById('board');
  const selectedCount=document.getElementById('selectedCount');
  const pairsLeft=document.getElementById('pairsLeft');
  const tilesLeft=document.getElementById('tilesLeft');
  const scoreEl=document.getElementById('score');
  const restartBtn=document.getElementById('restart');
  const shuffleBtn=document.getElementById('shuffle');
  const hintBtn=document.getElementById('hintBtn');
  const undoBtn=document.getElementById('undoBtn');
  const toast=document.getElementById('toast');
  const modeSelect=document.getElementById('modeSelect');
  const kanjiLessonSelect=document.getElementById('kanjiLessonSelect');
  const descText=document.getElementById('descText');

  let selected=[]; let history=[]; let score=0; 

  function isCovered(tile){return tiles.some(t=>!t.removed && t.layer>tile.layer && t.x===tile.x && t.y===tile.y);}
  function hasNeighbor(tile,dx){return tiles.some(t=>!t.removed && t.layer===tile.layer && t.y===tile.y && t.x===tile.x+dx);}
  function isFree(tile){if(!tile||tile.removed) return false; if(isCovered(tile)) return false; return !hasNeighbor(tile,-2)||!hasNeighbor(tile,2);}
  
  function setHelperButtons(enabled) {
      shuffleBtn.disabled = !enabled;
      hintBtn.disabled = !enabled;
      undoBtn.disabled = !enabled;
  }

  function renderBoard(){
    board.innerHTML='';
    const xs=tiles.map(t=>t.x), ys=tiles.map(t=>t.y);
    const minX=Math.min(...xs), minY=Math.min(...ys);
    
    tiles.slice().sort((a,b)=>a.layer-b.layer||a.y-b.y||a.x-b.x).forEach(t=>{
      if(t.removed) return;
      
      // Check if tile already exists (to avoid re-creating elements that are glowing/scaling)
      let el = document.querySelector(`[data-id="${t.id}"]`);
      if (el) {
         // If element exists, only update classes, not entire innerHTML
      } else {
         el = document.createElement('div');
         el.dataset.id = t.id;
         el.addEventListener('click',()=>onTileClick(t.id));
         board.appendChild(el);
      }
      
      let fontSize = t.char.length > 2 ? '18px' : '24px'; /* Adjusted for smaller tiles */
      let isKanjiChar = false;
      
      if (currentMode === 'kanji') {
          if (KANJI_LESSONS[currentKanjiLessonId] && KANJI_LESSONS[currentKanjiLessonId].pairs.length > 0 && !(currentKanjiLessonId === 'L1' || currentKanjiLessonId === 'L2')) {
             isKanjiChar = KANJI_LESSONS[currentKanjiLessonId].pairs.some(p => p.kanji === t.char);
          } else {
             isKanjiChar = !isNaN(parseInt(t.char)) && isFinite(t.char) && t.char.length > 0;
          }

          if (isKanjiChar) { 
              if (t.char.length <= 2) { 
                 fontSize = '30px'; /* Adjusted kanji font size */
              } else {
                 fontSize = '18px';
              }
          }
      }
      
      // 1. Set base classes (including locked/free)
      el.className='tile layer-'+t.layer+(isFree(t)?' free':' locked');
      if (isKanjiChar) el.classList.add('kanji-char');
      
      // 2. Preserve existing glow2 state (Match success)
      if(el.classList.contains('glow2')) {
        // Keep glow2 and scale transform, skip font size update to avoid flicking
      } else {
        el.style.fontSize = fontSize; 
      }
      
      // 3. Handle Selected State: Add 'selected' class and 'glow' effect for single selection.
      if(selected.includes(t.id)) {
          el.classList.add('selected');
          // Add yellow glow for the first selection (unless match success glow is active)
          if(!el.classList.contains('glow2')) { 
              el.classList.add('glow');
          }
      } else {
          // Remove selection classes if tile is not selected
          el.classList.remove('selected');
          
          // Remove 'glow' unless it's the match glow (glow2)
          if(!el.classList.contains('glow2')) {
              el.classList.remove('glow');
          }
      }
      // --- END Selection/Glow logic ---

      const baseX=60, baseY=40;
      // ADJUSTED Horizontal Step: TILE_WIDTH / 2 + 14 (40 + 14 = 54)
      const horizontalStep = TILE_WIDTH / 2 + 14; 
      // ADJUSTED Vertical Step: TILE_HEIGHT / 2 + 4 (30 + 4 = 34)
      const verticalStep = TILE_HEIGHT / 2 + 4; 

      const left=baseX+(t.x-minX)*horizontalStep+t.layer*10; 
      const top=baseY+(t.y-minY)*verticalStep-t.layer*8;
      
      el.style.left=left+'px'; el.style.top=top+'px';
      el.style.zIndex=100+t.layer*10+t.y*2;
      el.style.opacity=1;
      
      // Update content only if it was newly created or content changed (optional optimization, safe to do this every time)
      if (el.innerHTML === '' || el.innerHTML.indexOf(t.char) === -1) {
        el.innerHTML=`<div>${t.char}</div><div class="corner tl">${t.char}</div><div class="corner tr">${t.char}</div><div class="corner bl">${t.char}</div><div class="corner br">${t.char}</div>`;
      }
    });
    
    // Remove tiles that are no longer in the tiles array (i.e., removed)
    Array.from(board.children).forEach(el => {
        const id = parseInt(el.dataset.id);
        if (!tiles.some(t => t.id === id && !t.removed)) {
            if (!el.classList.contains('removed')) { // To prevent re-running transition logic if already hidden
                el.style.opacity = '0';
                el.classList.add('removed');
                setTimeout(() => el.remove(), 300); // Wait for transition
            }
        }
    });

    const leftCount=tiles.filter(t=>!t.removed).length;
    if(selectedCount) selectedCount.textContent=selected.length;
    if(tilesLeft) tilesLeft.textContent=leftCount; if(pairsLeft) pairsLeft.textContent=Math.floor(leftCount/2);
  }

  function onTileClick(id){
    if(gameFinished) return; 
    
    const tile=tiles.find(t=>t.id===id);
    if(!tile||tile.removed) return;
    if(!isFree(tile)){flashToast('Tile is blocked'); return;}
    
    // Deselect if already selected
    if(selected.includes(id)){selected=selected.filter(x=>x!==id); renderBoard(); return;}
    
    // Select first tile (renderBoard will now apply the glow)
    if(selected.length===0){selected.push(id); renderBoard(); return;}
    
    // Select second tile and check match
    if(selected.length===1){
      selected.push(id); 
      // é¸æŠçŠ¶æ…‹ã‚’åæ˜ ã™ã‚‹ãŸã‚ã«ä¸€åº¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° (2æšç›®ã‚‚selected/glowãŒé©ç”¨ã•ã‚Œã‚‹)
      renderBoard(); 
      const a=tiles.find(t=>t.id===selected[0]), b=tiles.find(t=>t.id===selected[1]);
      
      if(a && b && isMatch(a.char, b.char) && a.id !== b.id){
        
        // --- MATCH SUCCESS: Apply GLOW2 (Pink/Red) and SCALE EFFECT with delay ---
        const aEl = document.querySelector(`[data-id="${a.id}"]`);
        const bEl = document.querySelector(`[data-id="${b.id}"]`);
        
        // 1. Immediate Visual Effects (Glow and Scale) - Overrides 'glow' with 'glow2'
        aEl.classList.add('glow2'); 
        bEl.classList.add('glow2'); 
        
        selected = []; // é¸æŠçŠ¶æ…‹ã‚’è§£é™¤ (renderBoard()ã®æ¬¡å›å®Ÿè¡Œã§'selected'ã¨'glow'ã¯é™¤å»ã•ã‚Œã‚‹)
        
        // 2. Schedule Removal and Score Update (500ms delay for visibility)
        setTimeout(() => {
          // Glowè§£é™¤ã¨åŒæ™‚ã«é™¤å»
          aEl.classList.remove('glow2'); 
          bEl.classList.remove('glow2'); 
          // å¿µã®ãŸã‚ã€selection glowã‚‚é™¤å»
          aEl.classList.remove('glow'); 
          bEl.classList.remove('glow'); 

          // Actual removal and game state update
          history.push({type:'remove', tiles:[a.id,b.id]}); 
          a.removed=true; b.removed=true; 
          score+=10; 
          if(scoreEl) scoreEl.textContent=score; 
          
          renderBoard(); 
          checkWin();
          
          // --- V24 ENHANCEMENT: Automatic Hint Check after removal ---
          if (!gameFinished && findHint() === null) {
              // Automatically notify the user that they are stuck and need to shuffle
              flashToast('ğŸš¨ STUCK! No matching pairs are currently free. Try shuffling! (Penalty: -10 points)', 4000);
          }
          // ---------------------------------------------------------
        }, 500); 

      } else {
        // Not a match: Deselect after 400ms flash
        setTimeout(()=>{selected=[]; renderBoard();},500); 
        flashToast('Not a match');
      }
    }
  }

  function checkWin(){
    if(tiles.every(t=>t.removed)){
      gameFinished = true; 
      setHelperButtons(false); 
      toast.textContent = 'You win! Score:'+score; 
      toast.style.opacity='1'; toast.style.display='block';
      toast.addEventListener('click',()=>{toast.style.display='none'; toast.style.opacity='0';}, {once:true});
    }
  }

  function flashToast(msg,timeout=1200){toast.textContent=msg; toast.style.opacity='1'; toast.style.display='block'; setTimeout(()=>{toast.style.opacity='0';},timeout); setTimeout(()=>{toast.style.display='none';},timeout+300);}

  function restartGame(){
      selected=[]; 
      history=[]; 
      score=0; 
      gameFinished = false; 
      if(scoreEl) scoreEl.textContent=score; 
      board.innerHTML=''; 
      buildTiles(); 
      renderBoard(); 
      setHelperButtons(true); 
      flashToast('Restarted!');
  }

  // --- Kanji Lesson Selector Population and Handling ---
  function populateLessonSelector() {
      kanjiLessonSelect.innerHTML = '';
      
      let firstLesson = true;
      for (const id in KANJI_LESSONS) {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = KANJI_LESSONS[id].name;
          kanjiLessonSelect.appendChild(option);
          
          if (firstLesson) {
             currentKanjiLessonId = id; 
             firstLesson = false;
          }
      }
      updateLessonDescription(currentKanjiLessonId);
  }

  function updateLessonDescription(id) {
       const lessonName = KANJI_LESSONS[id].name;
       let ruleText = "Match Kanji to Hiragana reading.";
       if (id === 'L1') {
           ruleText = "Match Random Number Digits (1-99) to Hiragana reading.";
       } else if (id === 'L2') {
           ruleText = "Match Random Number Digits (1-99) to Katakana reading.";
       }
       descText.textContent = ` æ¼¢å­— Kanji Challenge: Active Lesson: ${lessonName}. ${ruleText}`;
  }
  
  populateLessonSelector(); 
  
  kanjiLessonSelect.addEventListener('change', (e) => {
    currentKanjiLessonId = e.target.value;
    updateLessonDescription(currentKanjiLessonId);
    restartGame();
  });
  
  modeSelect.addEventListener('change', (e) => {
    const val = e.target.value;
    currentMode = val;
    
    if (val === 'kanji') {
        kanjiLessonSelect.style.display = 'inline-block';
        
        if (!KANJI_LESSONS[currentKanjiLessonId]) {
             currentKanjiLessonId = kanjiLessonSelect.value;
        }

        updateLessonDescription(currentKanjiLessonId);
        
    } else {
        kanjiLessonSelect.style.display = 'none';
        if(val === 'katakana') {
            currentSet = KATAKANA;
            descText.textContent = "Katakana mode active. Match identical characters.";
        } else if (val === 'mixed') {
            currentSet = HIRAGANA.concat(KATAKANA);
            descText.textContent = "Mixed mode: Match identical characters (ã‚=ã‚ OR ã‚¢=ã‚¢).";
        } else if (val === 'hard') {
            currentSet = HIRAGANA.concat(KATAKANA); 
            descText.textContent = "ğŸ”¥ HARD MODE: Match Hiragana to its Katakana counterpart (ã‚=ã‚¢).";
        } else {
            currentSet = HIRAGANA;
            descText.textContent = "Hiragana mode active. Match identical characters.";
        }
    }
    
    restartGame();
  });

  restartBtn.addEventListener('click',restartGame);
  
  // Shuffle Button Event Listener
  shuffleBtn.addEventListener('click', () => {
      if(gameFinished) return;
      const penalty = 10;
      score = Math.max(0, score - penalty);
      if(scoreEl) scoreEl.textContent = score;
      shuffleBoard();
      flashToast(`Shuffled! (-${penalty} points)`); 
  });


  hintBtn.addEventListener('click',()=>{
      if(gameFinished) return;
      const h=findHint();
      if(h){
        const penalty = 5;
        score = Math.max(0, score - penalty);
        if(scoreEl) scoreEl.textContent = score;
        flashToast(`Hint shown (-${penalty} points)`); 
        const els = [];
        h.forEach(id=>{
          const el = document.querySelector(`[data-id="${id}"]`);
          if(el){ 
             const originalFontSize = el.style.fontSize;
             el.classList.add('glow'); // HINT uses 'glow' (Stronger Yellow)
             el.style.fontSize = '40px'; 
             els.push({el: el, originalFontSize: originalFontSize}); 
          }
        });
        setTimeout(()=>{ 
            els.forEach(item => {
                item.el.classList.remove('glow');
                item.el.style.fontSize = item.originalFontSize;
            }); 
        },2000);
      } else {
        // This is the manual check fallback. The message is the same.
        flashToast('No matching pairs are currently free. Try shuffling! (Shuffle penalty: -10 points)', 3000);
      }
    });
  
  // Undo button check
  undoBtn.addEventListener('click',()=>{
      if(gameFinished) return;
      const act=history.pop(); 
      if(!act){
          flashToast('Nothing to undo'); 
          return;
      } 
      if(act.type==='remove') act.tiles.forEach(id=>{
          const t=tiles.find(x=>x.id===id); 
          if(t) t.removed=false;
      }); 
      renderBoard();
  });

  // Hint logic updated to use isMatch
  function findHint(){
      const freeTiles=tiles.filter(t=>!t.removed && isFree(t)); 
      for(let i=0;i<freeTiles.length;i++){
          for(let j=i+1;j<freeTiles.length;j++){
              if(freeTiles[i].id !== freeTiles[j].id && isMatch(freeTiles[i].char, freeTiles[j].char)) {
                  return [freeTiles[i].id,freeTiles[j].id];
              }
          }
      } 
      return null;
  }
  
  restartGame(); 
})();
</script>
</body>
</html>